# 左神算法视频笔记

## P2

### 异或

位逻辑异或：`a^b`  相同为0，不同为1。可理解为二进制无进位相加。

eg：

```java 
int a=0b10110;
int b=0b10010;
c=a+b;//c=0b00100
```

**性质：**

![image-20211110222411835](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211110222411835.png)

推出一个抖机灵的交换两数的方法(**前提：a,b不在同一内存**)：

```java 
int a=9;//1001
int b=8;//1000		

a=a^b;//a=a^b;b=b;
b=a^b;//a=a^b;b=a^b^b=a;
a=a^b;//a=a^b^a=b;b=a;
```

**练习：**



`int[] arr`中只有**一个数**出现了奇数次，other偶数次，求这个数。

解题思路：

1.N^N=0，偶数个的全为0。

2.整体进行无进位相加,只有位数中含有奇数个1的会为1，即那个数。

```java
public static void PrintOddTimesNum1(int[] arr){
	int ans = 0;
    for(int cur : arr){
		ans ^= cur;
    }
    
}
```



`int[] arr`中只有**两个数**出现了奇数次，other偶数次，求这个数。

解题思路：

整体异或完后，`xor=a^b`;其中`xor`中为1的位为a,b中不相等的位。以此位将数组分成两部分。分别异或得到a,b;

```java
public static void PrintOddTimesNum1(int[] arr){
	int xor = 0;
    for(int cur : arr){
		xor ^= cur;
    }

    int rightOne = xor & (~xor + 1);// 提出最右位的1
    
    int ans1 = 0;
    for(int cur : arr){
		if(cur & rightOne == 0){// 将数组分成两部分
            ans1 ^= cur;
        }
    }
    ans2 = xor ^ ans1;
    
}
```

### 与

位逻辑与：&，全1为1，否则为0。

### 通过异或和与运算提出最右位的1

```java
int rightOne = xor & (~xor + 1);// 提出最右位的1
```

eg：

```java
int a = 0b00110;
int rightOne = a & (~a + 1);// 00110 & 11010 = 00010;
```



## P3

### 递归的时间复杂度--master公式

问题：用递归找数组的最大值

```java
public static int getMax(int[] arr){
	return process(arr,0,arr.length-1);
}

public static int process(int[] arr,int L, int R){
	if(L == R){
		return arr[L];
	}
	int mid = L+((R-L) >> 1);//通过左移一位完成/2操作
	int leftMax = process(arr, L, mid);
	int rightMax = process(arr, mid+1, R);
	return Math.max(leftMax,rightMax);
}
```

![image-20211117122033899](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211117122033899.png)

**要求**：子问题等规模

a:子问题数量 ，上例为2

N/b:子问题规模 ，上例为N/2

N^d:除去子过程之外剩下问题的时间复杂度,上例为1

### 左移右移

<<（左移）和>>（右移）。

左移运算是将一个二进制位的[操作数](https://baike.baidu.com/item/操作数/7658270)按指定移动的位数向左移位，移出位被丢弃，右边的空位一律补0。

右移类似。

每左移一位相当于*2；

每右移一位相当于/2;

eg:

```java
//左移
int a = 0111;// a=0b0000000100010001;
int b = a << 3;// b=0b0000100010001000; b=0888;

```

```java
//右移
int a = 0111;// a=0b0000000100010001;
int b = a >> 3;// b=0b0000000000010001; b=0006;

```



注意溢出问题。
